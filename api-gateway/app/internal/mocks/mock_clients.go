// Code generated by MockGen. DO NOT EDIT.
// Source: api-gateway/internal/clients (interfaces: TabGenerator,AudioSeparator)
//
// Generated by this command:
//
//	mockgen -destination=internal/mocks/mock_clients.go -package=mocks api-gateway/internal/clients TabGenerator,AudioSeparator
//

// Package mocks is a generated GoMock package.
package mocks

import (
	separator "api-gateway/internal/proto/separator"
	tab "api-gateway/internal/proto/tab"
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockTabGenerator is a mock of TabGenerator interface.
type MockTabGenerator struct {
	ctrl     *gomock.Controller
	recorder *MockTabGeneratorMockRecorder
	isgomock struct{}
}

// MockTabGeneratorMockRecorder is the mock recorder for MockTabGenerator.
type MockTabGeneratorMockRecorder struct {
	mock *MockTabGenerator
}

// NewMockTabGenerator creates a new mock instance.
func NewMockTabGenerator(ctrl *gomock.Controller) *MockTabGenerator {
	mock := &MockTabGenerator{ctrl: ctrl}
	mock.recorder = &MockTabGeneratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTabGenerator) EXPECT() *MockTabGeneratorMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockTabGenerator) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockTabGeneratorMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockTabGenerator)(nil).Close))
}

// GenerateTab mocks base method.
func (m *MockTabGenerator) GenerateTab(ctx context.Context, fileName string, audioData []byte) (*tab.TabResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateTab", ctx, fileName, audioData)
	ret0, _ := ret[0].(*tab.TabResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GenerateTab indicates an expected call of GenerateTab.
func (mr *MockTabGeneratorMockRecorder) GenerateTab(ctx, fileName, audioData any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateTab", reflect.TypeOf((*MockTabGenerator)(nil).GenerateTab), ctx, fileName, audioData)
}

// MockAudioSeparator is a mock of AudioSeparator interface.
type MockAudioSeparator struct {
	ctrl     *gomock.Controller
	recorder *MockAudioSeparatorMockRecorder
	isgomock struct{}
}

// MockAudioSeparatorMockRecorder is the mock recorder for MockAudioSeparator.
type MockAudioSeparatorMockRecorder struct {
	mock *MockAudioSeparator
}

// NewMockAudioSeparator creates a new mock instance.
func NewMockAudioSeparator(ctrl *gomock.Controller) *MockAudioSeparator {
	mock := &MockAudioSeparator{ctrl: ctrl}
	mock.recorder = &MockAudioSeparatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAudioSeparator) EXPECT() *MockAudioSeparatorMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *MockAudioSeparator) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockAudioSeparatorMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockAudioSeparator)(nil).Close))
}

// SeparateAudio mocks base method.
func (m *MockAudioSeparator) SeparateAudio(ctx context.Context, fileName string, audioData []byte) (map[string]*separator.AudioFileData, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SeparateAudio", ctx, fileName, audioData)
	ret0, _ := ret[0].(map[string]*separator.AudioFileData)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SeparateAudio indicates an expected call of SeparateAudio.
func (mr *MockAudioSeparatorMockRecorder) SeparateAudio(ctx, fileName, audioData any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SeparateAudio", reflect.TypeOf((*MockAudioSeparator)(nil).SeparateAudio), ctx, fileName, audioData)
}
