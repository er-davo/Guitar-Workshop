// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: proto/processor.proto
// Protobuf C++ Version: 5.27.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fprocessor_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fprocessor_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_proto_2fprocessor_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fprocessor_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_proto_2fprocessor_2eproto;
namespace audioproc {
class AudioChunk;
struct AudioChunkDefaultTypeInternal;
extern AudioChunkDefaultTypeInternal _AudioChunk_default_instance_;
class AudioProcessingConfig;
struct AudioProcessingConfigDefaultTypeInternal;
extern AudioProcessingConfigDefaultTypeInternal _AudioProcessingConfig_default_instance_;
class ChunkingConfig;
struct ChunkingConfigDefaultTypeInternal;
extern ChunkingConfigDefaultTypeInternal _ChunkingConfig_default_instance_;
class ProcessAudioRequest;
struct ProcessAudioRequestDefaultTypeInternal;
extern ProcessAudioRequestDefaultTypeInternal _ProcessAudioRequest_default_instance_;
class ProcessAudioResponse;
struct ProcessAudioResponseDefaultTypeInternal;
extern ProcessAudioResponseDefaultTypeInternal _ProcessAudioResponse_default_instance_;
class SplitAudioRequest;
struct SplitAudioRequestDefaultTypeInternal;
extern SplitAudioRequestDefaultTypeInternal _SplitAudioRequest_default_instance_;
class SplitAudioResponse;
struct SplitAudioResponseDefaultTypeInternal;
extern SplitAudioResponseDefaultTypeInternal _SplitAudioResponse_default_instance_;
}  // namespace audioproc
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace audioproc {

// ===================================================================


// -------------------------------------------------------------------

class ProcessAudioResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:audioproc.ProcessAudioResponse) */ {
 public:
  inline ProcessAudioResponse() : ProcessAudioResponse(nullptr) {}
  ~ProcessAudioResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProcessAudioResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ProcessAudioResponse(const ProcessAudioResponse& from) : ProcessAudioResponse(nullptr, from) {}
  inline ProcessAudioResponse(ProcessAudioResponse&& from) noexcept
      : ProcessAudioResponse(nullptr, std::move(from)) {}
  inline ProcessAudioResponse& operator=(const ProcessAudioResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessAudioResponse& operator=(ProcessAudioResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessAudioResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessAudioResponse* internal_default_instance() {
    return reinterpret_cast<const ProcessAudioResponse*>(
        &_ProcessAudioResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ProcessAudioResponse& a, ProcessAudioResponse& b) { a.Swap(&b); }
  inline void Swap(ProcessAudioResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessAudioResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessAudioResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ProcessAudioResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProcessAudioResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ProcessAudioResponse& from) { ProcessAudioResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProcessAudioResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "audioproc.ProcessAudioResponse"; }

 protected:
  explicit ProcessAudioResponse(::google::protobuf::Arena* arena);
  ProcessAudioResponse(::google::protobuf::Arena* arena, const ProcessAudioResponse& from);
  ProcessAudioResponse(::google::protobuf::Arena* arena, ProcessAudioResponse&& from) noexcept
      : ProcessAudioResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWavDataFieldNumber = 1,
  };
  // bytes wav_data = 1;
  void clear_wav_data() ;
  const std::string& wav_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_wav_data(Arg_&& arg, Args_... args);
  std::string* mutable_wav_data();
  PROTOBUF_NODISCARD std::string* release_wav_data();
  void set_allocated_wav_data(std::string* value);

  private:
  const std::string& _internal_wav_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wav_data(
      const std::string& value);
  std::string* _internal_mutable_wav_data();

  public:
  // @@protoc_insertion_point(class_scope:audioproc.ProcessAudioResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ProcessAudioResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ProcessAudioResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr wav_data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fprocessor_2eproto;
};
// -------------------------------------------------------------------

class ChunkingConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:audioproc.ChunkingConfig) */ {
 public:
  inline ChunkingConfig() : ChunkingConfig(nullptr) {}
  ~ChunkingConfig() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChunkingConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChunkingConfig(const ChunkingConfig& from) : ChunkingConfig(nullptr, from) {}
  inline ChunkingConfig(ChunkingConfig&& from) noexcept
      : ChunkingConfig(nullptr, std::move(from)) {}
  inline ChunkingConfig& operator=(const ChunkingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChunkingConfig& operator=(ChunkingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChunkingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChunkingConfig* internal_default_instance() {
    return reinterpret_cast<const ChunkingConfig*>(
        &_ChunkingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ChunkingConfig& a, ChunkingConfig& b) { a.Swap(&b); }
  inline void Swap(ChunkingConfig* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChunkingConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChunkingConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ChunkingConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChunkingConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChunkingConfig& from) { ChunkingConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChunkingConfig* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "audioproc.ChunkingConfig"; }

 protected:
  explicit ChunkingConfig(::google::protobuf::Arena* arena);
  ChunkingConfig(::google::protobuf::Arena* arena, const ChunkingConfig& from);
  ChunkingConfig(::google::protobuf::Arena* arena, ChunkingConfig&& from) noexcept
      : ChunkingConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSampleRateFieldNumber = 1,
    kThresholdFieldNumber = 2,
    kChunkMinDurationSecFieldNumber = 3,
    kChunkMaxDurationSecFieldNumber = 4,
    kOverlapDurationSecFieldNumber = 5,
  };
  // int32 sample_rate = 1;
  void clear_sample_rate() ;
  ::int32_t sample_rate() const;
  void set_sample_rate(::int32_t value);

  private:
  ::int32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(::int32_t value);

  public:
  // float threshold = 2;
  void clear_threshold() ;
  float threshold() const;
  void set_threshold(float value);

  private:
  float _internal_threshold() const;
  void _internal_set_threshold(float value);

  public:
  // float chunk_min_duration_sec = 3;
  void clear_chunk_min_duration_sec() ;
  float chunk_min_duration_sec() const;
  void set_chunk_min_duration_sec(float value);

  private:
  float _internal_chunk_min_duration_sec() const;
  void _internal_set_chunk_min_duration_sec(float value);

  public:
  // float chunk_max_duration_sec = 4;
  void clear_chunk_max_duration_sec() ;
  float chunk_max_duration_sec() const;
  void set_chunk_max_duration_sec(float value);

  private:
  float _internal_chunk_max_duration_sec() const;
  void _internal_set_chunk_max_duration_sec(float value);

  public:
  // float overlap_duration_sec = 5;
  void clear_overlap_duration_sec() ;
  float overlap_duration_sec() const;
  void set_overlap_duration_sec(float value);

  private:
  float _internal_overlap_duration_sec() const;
  void _internal_set_overlap_duration_sec(float value);

  public:
  // @@protoc_insertion_point(class_scope:audioproc.ChunkingConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ChunkingConfig_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ChunkingConfig& from_msg);
    ::int32_t sample_rate_;
    float threshold_;
    float chunk_min_duration_sec_;
    float chunk_max_duration_sec_;
    float overlap_duration_sec_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fprocessor_2eproto;
};
// -------------------------------------------------------------------

class AudioProcessingConfig final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:audioproc.AudioProcessingConfig) */ {
 public:
  inline AudioProcessingConfig() : AudioProcessingConfig(nullptr) {}
  ~AudioProcessingConfig() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AudioProcessingConfig(
      ::google::protobuf::internal::ConstantInitialized);

  inline AudioProcessingConfig(const AudioProcessingConfig& from) : AudioProcessingConfig(nullptr, from) {}
  inline AudioProcessingConfig(AudioProcessingConfig&& from) noexcept
      : AudioProcessingConfig(nullptr, std::move(from)) {}
  inline AudioProcessingConfig& operator=(const AudioProcessingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioProcessingConfig& operator=(AudioProcessingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioProcessingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioProcessingConfig* internal_default_instance() {
    return reinterpret_cast<const AudioProcessingConfig*>(
        &_AudioProcessingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(AudioProcessingConfig& a, AudioProcessingConfig& b) { a.Swap(&b); }
  inline void Swap(AudioProcessingConfig* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioProcessingConfig* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioProcessingConfig* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AudioProcessingConfig>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AudioProcessingConfig& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AudioProcessingConfig& from) { AudioProcessingConfig::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AudioProcessingConfig* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "audioproc.AudioProcessingConfig"; }

 protected:
  explicit AudioProcessingConfig(::google::protobuf::Arena* arena);
  AudioProcessingConfig(::google::protobuf::Arena* arena, const AudioProcessingConfig& from);
  AudioProcessingConfig(::google::protobuf::Arena* arena, AudioProcessingConfig&& from) noexcept
      : AudioProcessingConfig(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kThresholdFieldNumber = 1,
    kMarginFieldNumber = 2,
    kHighPassFieldNumber = 3,
    kUseBandpassFieldNumber = 4,
    kBandLowFieldNumber = 5,
    kBandHighFieldNumber = 6,
    kFadeSamplesFieldNumber = 7,
    kSampleRateFieldNumber = 8,
  };
  // float threshold = 1;
  void clear_threshold() ;
  float threshold() const;
  void set_threshold(float value);

  private:
  float _internal_threshold() const;
  void _internal_set_threshold(float value);

  public:
  // int32 margin = 2;
  void clear_margin() ;
  ::int32_t margin() const;
  void set_margin(::int32_t value);

  private:
  ::int32_t _internal_margin() const;
  void _internal_set_margin(::int32_t value);

  public:
  // float high_pass = 3;
  void clear_high_pass() ;
  float high_pass() const;
  void set_high_pass(float value);

  private:
  float _internal_high_pass() const;
  void _internal_set_high_pass(float value);

  public:
  // bool use_bandpass = 4;
  void clear_use_bandpass() ;
  bool use_bandpass() const;
  void set_use_bandpass(bool value);

  private:
  bool _internal_use_bandpass() const;
  void _internal_set_use_bandpass(bool value);

  public:
  // float band_low = 5;
  void clear_band_low() ;
  float band_low() const;
  void set_band_low(float value);

  private:
  float _internal_band_low() const;
  void _internal_set_band_low(float value);

  public:
  // float band_high = 6;
  void clear_band_high() ;
  float band_high() const;
  void set_band_high(float value);

  private:
  float _internal_band_high() const;
  void _internal_set_band_high(float value);

  public:
  // int32 fade_samples = 7;
  void clear_fade_samples() ;
  ::int32_t fade_samples() const;
  void set_fade_samples(::int32_t value);

  private:
  ::int32_t _internal_fade_samples() const;
  void _internal_set_fade_samples(::int32_t value);

  public:
  // int32 sample_rate = 8;
  void clear_sample_rate() ;
  ::int32_t sample_rate() const;
  void set_sample_rate(::int32_t value);

  private:
  ::int32_t _internal_sample_rate() const;
  void _internal_set_sample_rate(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:audioproc.AudioProcessingConfig)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AudioProcessingConfig_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AudioProcessingConfig& from_msg);
    float threshold_;
    ::int32_t margin_;
    float high_pass_;
    bool use_bandpass_;
    float band_low_;
    float band_high_;
    ::int32_t fade_samples_;
    ::int32_t sample_rate_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fprocessor_2eproto;
};
// -------------------------------------------------------------------

class AudioChunk final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:audioproc.AudioChunk) */ {
 public:
  inline AudioChunk() : AudioChunk(nullptr) {}
  ~AudioChunk() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AudioChunk(
      ::google::protobuf::internal::ConstantInitialized);

  inline AudioChunk(const AudioChunk& from) : AudioChunk(nullptr, from) {}
  inline AudioChunk(AudioChunk&& from) noexcept
      : AudioChunk(nullptr, std::move(from)) {}
  inline AudioChunk& operator=(const AudioChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioChunk& operator=(AudioChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AudioChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioChunk* internal_default_instance() {
    return reinterpret_cast<const AudioChunk*>(
        &_AudioChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(AudioChunk& a, AudioChunk& b) { a.Swap(&b); }
  inline void Swap(AudioChunk* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioChunk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioChunk* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AudioChunk>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AudioChunk& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AudioChunk& from) { AudioChunk::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AudioChunk* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "audioproc.AudioChunk"; }

 protected:
  explicit AudioChunk(::google::protobuf::Arena* arena);
  AudioChunk(::google::protobuf::Arena* arena, const AudioChunk& from);
  AudioChunk(::google::protobuf::Arena* arena, AudioChunk&& from) noexcept
      : AudioChunk(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAudioDataFieldNumber = 2,
    kStartTimeFieldNumber = 1,
  };
  // bytes audio_data = 2;
  void clear_audio_data() ;
  const std::string& audio_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_audio_data(Arg_&& arg, Args_... args);
  std::string* mutable_audio_data();
  PROTOBUF_NODISCARD std::string* release_audio_data();
  void set_allocated_audio_data(std::string* value);

  private:
  const std::string& _internal_audio_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_data(
      const std::string& value);
  std::string* _internal_mutable_audio_data();

  public:
  // float start_time = 1;
  void clear_start_time() ;
  float start_time() const;
  void set_start_time(float value);

  private:
  float _internal_start_time() const;
  void _internal_set_start_time(float value);

  public:
  // @@protoc_insertion_point(class_scope:audioproc.AudioChunk)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AudioChunk_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AudioChunk& from_msg);
    ::google::protobuf::internal::ArenaStringPtr audio_data_;
    float start_time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fprocessor_2eproto;
};
// -------------------------------------------------------------------

class SplitAudioResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:audioproc.SplitAudioResponse) */ {
 public:
  inline SplitAudioResponse() : SplitAudioResponse(nullptr) {}
  ~SplitAudioResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SplitAudioResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SplitAudioResponse(const SplitAudioResponse& from) : SplitAudioResponse(nullptr, from) {}
  inline SplitAudioResponse(SplitAudioResponse&& from) noexcept
      : SplitAudioResponse(nullptr, std::move(from)) {}
  inline SplitAudioResponse& operator=(const SplitAudioResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SplitAudioResponse& operator=(SplitAudioResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SplitAudioResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SplitAudioResponse* internal_default_instance() {
    return reinterpret_cast<const SplitAudioResponse*>(
        &_SplitAudioResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(SplitAudioResponse& a, SplitAudioResponse& b) { a.Swap(&b); }
  inline void Swap(SplitAudioResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SplitAudioResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SplitAudioResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SplitAudioResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SplitAudioResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SplitAudioResponse& from) { SplitAudioResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SplitAudioResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "audioproc.SplitAudioResponse"; }

 protected:
  explicit SplitAudioResponse(::google::protobuf::Arena* arena);
  SplitAudioResponse(::google::protobuf::Arena* arena, const SplitAudioResponse& from);
  SplitAudioResponse(::google::protobuf::Arena* arena, SplitAudioResponse&& from) noexcept
      : SplitAudioResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChunksFieldNumber = 1,
  };
  // repeated .audioproc.AudioChunk chunks = 1;
  int chunks_size() const;
  private:
  int _internal_chunks_size() const;

  public:
  void clear_chunks() ;
  ::audioproc::AudioChunk* mutable_chunks(int index);
  ::google::protobuf::RepeatedPtrField<::audioproc::AudioChunk>* mutable_chunks();

  private:
  const ::google::protobuf::RepeatedPtrField<::audioproc::AudioChunk>& _internal_chunks() const;
  ::google::protobuf::RepeatedPtrField<::audioproc::AudioChunk>* _internal_mutable_chunks();
  public:
  const ::audioproc::AudioChunk& chunks(int index) const;
  ::audioproc::AudioChunk* add_chunks();
  const ::google::protobuf::RepeatedPtrField<::audioproc::AudioChunk>& chunks() const;
  // @@protoc_insertion_point(class_scope:audioproc.SplitAudioResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SplitAudioResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SplitAudioResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::audioproc::AudioChunk > chunks_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fprocessor_2eproto;
};
// -------------------------------------------------------------------

class SplitAudioRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:audioproc.SplitAudioRequest) */ {
 public:
  inline SplitAudioRequest() : SplitAudioRequest(nullptr) {}
  ~SplitAudioRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SplitAudioRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SplitAudioRequest(const SplitAudioRequest& from) : SplitAudioRequest(nullptr, from) {}
  inline SplitAudioRequest(SplitAudioRequest&& from) noexcept
      : SplitAudioRequest(nullptr, std::move(from)) {}
  inline SplitAudioRequest& operator=(const SplitAudioRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SplitAudioRequest& operator=(SplitAudioRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SplitAudioRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SplitAudioRequest* internal_default_instance() {
    return reinterpret_cast<const SplitAudioRequest*>(
        &_SplitAudioRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(SplitAudioRequest& a, SplitAudioRequest& b) { a.Swap(&b); }
  inline void Swap(SplitAudioRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SplitAudioRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SplitAudioRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SplitAudioRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SplitAudioRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SplitAudioRequest& from) { SplitAudioRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SplitAudioRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "audioproc.SplitAudioRequest"; }

 protected:
  explicit SplitAudioRequest(::google::protobuf::Arena* arena);
  SplitAudioRequest(::google::protobuf::Arena* arena, const SplitAudioRequest& from);
  SplitAudioRequest(::google::protobuf::Arena* arena, SplitAudioRequest&& from) noexcept
      : SplitAudioRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWavDataFieldNumber = 1,
    kFileNameFieldNumber = 2,
    kConfigFieldNumber = 3,
  };
  // bytes wav_data = 1;
  void clear_wav_data() ;
  const std::string& wav_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_wav_data(Arg_&& arg, Args_... args);
  std::string* mutable_wav_data();
  PROTOBUF_NODISCARD std::string* release_wav_data();
  void set_allocated_wav_data(std::string* value);

  private:
  const std::string& _internal_wav_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wav_data(
      const std::string& value);
  std::string* _internal_mutable_wav_data();

  public:
  // string file_name = 2;
  void clear_file_name() ;
  const std::string& file_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_name(Arg_&& arg, Args_... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* value);

  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(
      const std::string& value);
  std::string* _internal_mutable_file_name();

  public:
  // .audioproc.ChunkingConfig config = 3;
  bool has_config() const;
  void clear_config() ;
  const ::audioproc::ChunkingConfig& config() const;
  PROTOBUF_NODISCARD ::audioproc::ChunkingConfig* release_config();
  ::audioproc::ChunkingConfig* mutable_config();
  void set_allocated_config(::audioproc::ChunkingConfig* value);
  void unsafe_arena_set_allocated_config(::audioproc::ChunkingConfig* value);
  ::audioproc::ChunkingConfig* unsafe_arena_release_config();

  private:
  const ::audioproc::ChunkingConfig& _internal_config() const;
  ::audioproc::ChunkingConfig* _internal_mutable_config();

  public:
  // @@protoc_insertion_point(class_scope:audioproc.SplitAudioRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      45, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SplitAudioRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SplitAudioRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr wav_data_;
    ::google::protobuf::internal::ArenaStringPtr file_name_;
    ::audioproc::ChunkingConfig* config_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fprocessor_2eproto;
};
// -------------------------------------------------------------------

class ProcessAudioRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:audioproc.ProcessAudioRequest) */ {
 public:
  inline ProcessAudioRequest() : ProcessAudioRequest(nullptr) {}
  ~ProcessAudioRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ProcessAudioRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ProcessAudioRequest(const ProcessAudioRequest& from) : ProcessAudioRequest(nullptr, from) {}
  inline ProcessAudioRequest(ProcessAudioRequest&& from) noexcept
      : ProcessAudioRequest(nullptr, std::move(from)) {}
  inline ProcessAudioRequest& operator=(const ProcessAudioRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcessAudioRequest& operator=(ProcessAudioRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcessAudioRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcessAudioRequest* internal_default_instance() {
    return reinterpret_cast<const ProcessAudioRequest*>(
        &_ProcessAudioRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ProcessAudioRequest& a, ProcessAudioRequest& b) { a.Swap(&b); }
  inline void Swap(ProcessAudioRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcessAudioRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcessAudioRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ProcessAudioRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ProcessAudioRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ProcessAudioRequest& from) { ProcessAudioRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ProcessAudioRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "audioproc.ProcessAudioRequest"; }

 protected:
  explicit ProcessAudioRequest(::google::protobuf::Arena* arena);
  ProcessAudioRequest(::google::protobuf::Arena* arena, const ProcessAudioRequest& from);
  ProcessAudioRequest(::google::protobuf::Arena* arena, ProcessAudioRequest&& from) noexcept
      : ProcessAudioRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWavDataFieldNumber = 1,
    kFileNameFieldNumber = 2,
    kConfigFieldNumber = 3,
  };
  // bytes wav_data = 1;
  void clear_wav_data() ;
  const std::string& wav_data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_wav_data(Arg_&& arg, Args_... args);
  std::string* mutable_wav_data();
  PROTOBUF_NODISCARD std::string* release_wav_data();
  void set_allocated_wav_data(std::string* value);

  private:
  const std::string& _internal_wav_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wav_data(
      const std::string& value);
  std::string* _internal_mutable_wav_data();

  public:
  // string file_name = 2;
  void clear_file_name() ;
  const std::string& file_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_name(Arg_&& arg, Args_... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* value);

  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(
      const std::string& value);
  std::string* _internal_mutable_file_name();

  public:
  // .audioproc.AudioProcessingConfig config = 3;
  bool has_config() const;
  void clear_config() ;
  const ::audioproc::AudioProcessingConfig& config() const;
  PROTOBUF_NODISCARD ::audioproc::AudioProcessingConfig* release_config();
  ::audioproc::AudioProcessingConfig* mutable_config();
  void set_allocated_config(::audioproc::AudioProcessingConfig* value);
  void unsafe_arena_set_allocated_config(::audioproc::AudioProcessingConfig* value);
  ::audioproc::AudioProcessingConfig* unsafe_arena_release_config();

  private:
  const ::audioproc::AudioProcessingConfig& _internal_config() const;
  ::audioproc::AudioProcessingConfig* _internal_mutable_config();

  public:
  // @@protoc_insertion_point(class_scope:audioproc.ProcessAudioRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      47, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ProcessAudioRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ProcessAudioRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr wav_data_;
    ::google::protobuf::internal::ArenaStringPtr file_name_;
    ::audioproc::AudioProcessingConfig* config_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fprocessor_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AudioProcessingConfig

// float threshold = 1;
inline void AudioProcessingConfig::clear_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threshold_ = 0;
}
inline float AudioProcessingConfig::threshold() const {
  // @@protoc_insertion_point(field_get:audioproc.AudioProcessingConfig.threshold)
  return _internal_threshold();
}
inline void AudioProcessingConfig::set_threshold(float value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:audioproc.AudioProcessingConfig.threshold)
}
inline float AudioProcessingConfig::_internal_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.threshold_;
}
inline void AudioProcessingConfig::_internal_set_threshold(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threshold_ = value;
}

// int32 margin = 2;
inline void AudioProcessingConfig::clear_margin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.margin_ = 0;
}
inline ::int32_t AudioProcessingConfig::margin() const {
  // @@protoc_insertion_point(field_get:audioproc.AudioProcessingConfig.margin)
  return _internal_margin();
}
inline void AudioProcessingConfig::set_margin(::int32_t value) {
  _internal_set_margin(value);
  // @@protoc_insertion_point(field_set:audioproc.AudioProcessingConfig.margin)
}
inline ::int32_t AudioProcessingConfig::_internal_margin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.margin_;
}
inline void AudioProcessingConfig::_internal_set_margin(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.margin_ = value;
}

// float high_pass = 3;
inline void AudioProcessingConfig::clear_high_pass() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_pass_ = 0;
}
inline float AudioProcessingConfig::high_pass() const {
  // @@protoc_insertion_point(field_get:audioproc.AudioProcessingConfig.high_pass)
  return _internal_high_pass();
}
inline void AudioProcessingConfig::set_high_pass(float value) {
  _internal_set_high_pass(value);
  // @@protoc_insertion_point(field_set:audioproc.AudioProcessingConfig.high_pass)
}
inline float AudioProcessingConfig::_internal_high_pass() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.high_pass_;
}
inline void AudioProcessingConfig::_internal_set_high_pass(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.high_pass_ = value;
}

// bool use_bandpass = 4;
inline void AudioProcessingConfig::clear_use_bandpass() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.use_bandpass_ = false;
}
inline bool AudioProcessingConfig::use_bandpass() const {
  // @@protoc_insertion_point(field_get:audioproc.AudioProcessingConfig.use_bandpass)
  return _internal_use_bandpass();
}
inline void AudioProcessingConfig::set_use_bandpass(bool value) {
  _internal_set_use_bandpass(value);
  // @@protoc_insertion_point(field_set:audioproc.AudioProcessingConfig.use_bandpass)
}
inline bool AudioProcessingConfig::_internal_use_bandpass() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.use_bandpass_;
}
inline void AudioProcessingConfig::_internal_set_use_bandpass(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.use_bandpass_ = value;
}

// float band_low = 5;
inline void AudioProcessingConfig::clear_band_low() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.band_low_ = 0;
}
inline float AudioProcessingConfig::band_low() const {
  // @@protoc_insertion_point(field_get:audioproc.AudioProcessingConfig.band_low)
  return _internal_band_low();
}
inline void AudioProcessingConfig::set_band_low(float value) {
  _internal_set_band_low(value);
  // @@protoc_insertion_point(field_set:audioproc.AudioProcessingConfig.band_low)
}
inline float AudioProcessingConfig::_internal_band_low() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.band_low_;
}
inline void AudioProcessingConfig::_internal_set_band_low(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.band_low_ = value;
}

// float band_high = 6;
inline void AudioProcessingConfig::clear_band_high() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.band_high_ = 0;
}
inline float AudioProcessingConfig::band_high() const {
  // @@protoc_insertion_point(field_get:audioproc.AudioProcessingConfig.band_high)
  return _internal_band_high();
}
inline void AudioProcessingConfig::set_band_high(float value) {
  _internal_set_band_high(value);
  // @@protoc_insertion_point(field_set:audioproc.AudioProcessingConfig.band_high)
}
inline float AudioProcessingConfig::_internal_band_high() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.band_high_;
}
inline void AudioProcessingConfig::_internal_set_band_high(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.band_high_ = value;
}

// int32 fade_samples = 7;
inline void AudioProcessingConfig::clear_fade_samples() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fade_samples_ = 0;
}
inline ::int32_t AudioProcessingConfig::fade_samples() const {
  // @@protoc_insertion_point(field_get:audioproc.AudioProcessingConfig.fade_samples)
  return _internal_fade_samples();
}
inline void AudioProcessingConfig::set_fade_samples(::int32_t value) {
  _internal_set_fade_samples(value);
  // @@protoc_insertion_point(field_set:audioproc.AudioProcessingConfig.fade_samples)
}
inline ::int32_t AudioProcessingConfig::_internal_fade_samples() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fade_samples_;
}
inline void AudioProcessingConfig::_internal_set_fade_samples(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fade_samples_ = value;
}

// int32 sample_rate = 8;
inline void AudioProcessingConfig::clear_sample_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_rate_ = 0;
}
inline ::int32_t AudioProcessingConfig::sample_rate() const {
  // @@protoc_insertion_point(field_get:audioproc.AudioProcessingConfig.sample_rate)
  return _internal_sample_rate();
}
inline void AudioProcessingConfig::set_sample_rate(::int32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:audioproc.AudioProcessingConfig.sample_rate)
}
inline ::int32_t AudioProcessingConfig::_internal_sample_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sample_rate_;
}
inline void AudioProcessingConfig::_internal_set_sample_rate(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_rate_ = value;
}

// -------------------------------------------------------------------

// ProcessAudioRequest

// bytes wav_data = 1;
inline void ProcessAudioRequest::clear_wav_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wav_data_.ClearToEmpty();
}
inline const std::string& ProcessAudioRequest::wav_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:audioproc.ProcessAudioRequest.wav_data)
  return _internal_wav_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcessAudioRequest::set_wav_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wav_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:audioproc.ProcessAudioRequest.wav_data)
}
inline std::string* ProcessAudioRequest::mutable_wav_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_wav_data();
  // @@protoc_insertion_point(field_mutable:audioproc.ProcessAudioRequest.wav_data)
  return _s;
}
inline const std::string& ProcessAudioRequest::_internal_wav_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wav_data_.Get();
}
inline void ProcessAudioRequest::_internal_set_wav_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wav_data_.Set(value, GetArena());
}
inline std::string* ProcessAudioRequest::_internal_mutable_wav_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.wav_data_.Mutable( GetArena());
}
inline std::string* ProcessAudioRequest::release_wav_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:audioproc.ProcessAudioRequest.wav_data)
  return _impl_.wav_data_.Release();
}
inline void ProcessAudioRequest::set_allocated_wav_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wav_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.wav_data_.IsDefault()) {
          _impl_.wav_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:audioproc.ProcessAudioRequest.wav_data)
}

// string file_name = 2;
inline void ProcessAudioRequest::clear_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& ProcessAudioRequest::file_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:audioproc.ProcessAudioRequest.file_name)
  return _internal_file_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcessAudioRequest::set_file_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:audioproc.ProcessAudioRequest.file_name)
}
inline std::string* ProcessAudioRequest::mutable_file_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:audioproc.ProcessAudioRequest.file_name)
  return _s;
}
inline const std::string& ProcessAudioRequest::_internal_file_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_name_.Get();
}
inline void ProcessAudioRequest::_internal_set_file_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.Set(value, GetArena());
}
inline std::string* ProcessAudioRequest::_internal_mutable_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.file_name_.Mutable( GetArena());
}
inline std::string* ProcessAudioRequest::release_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:audioproc.ProcessAudioRequest.file_name)
  return _impl_.file_name_.Release();
}
inline void ProcessAudioRequest::set_allocated_file_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.file_name_.IsDefault()) {
          _impl_.file_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:audioproc.ProcessAudioRequest.file_name)
}

// .audioproc.AudioProcessingConfig config = 3;
inline bool ProcessAudioRequest::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline void ProcessAudioRequest::clear_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.config_ != nullptr) _impl_.config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::audioproc::AudioProcessingConfig& ProcessAudioRequest::_internal_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::audioproc::AudioProcessingConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::audioproc::AudioProcessingConfig&>(::audioproc::_AudioProcessingConfig_default_instance_);
}
inline const ::audioproc::AudioProcessingConfig& ProcessAudioRequest::config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:audioproc.ProcessAudioRequest.config)
  return _internal_config();
}
inline void ProcessAudioRequest::unsafe_arena_set_allocated_config(::audioproc::AudioProcessingConfig* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = reinterpret_cast<::audioproc::AudioProcessingConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:audioproc.ProcessAudioRequest.config)
}
inline ::audioproc::AudioProcessingConfig* ProcessAudioRequest::release_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::audioproc::AudioProcessingConfig* released = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::audioproc::AudioProcessingConfig* ProcessAudioRequest::unsafe_arena_release_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:audioproc.ProcessAudioRequest.config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::audioproc::AudioProcessingConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::audioproc::AudioProcessingConfig* ProcessAudioRequest::_internal_mutable_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::audioproc::AudioProcessingConfig>(GetArena());
    _impl_.config_ = reinterpret_cast<::audioproc::AudioProcessingConfig*>(p);
  }
  return _impl_.config_;
}
inline ::audioproc::AudioProcessingConfig* ProcessAudioRequest::mutable_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::audioproc::AudioProcessingConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:audioproc.ProcessAudioRequest.config)
  return _msg;
}
inline void ProcessAudioRequest::set_allocated_config(::audioproc::AudioProcessingConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.config_ = reinterpret_cast<::audioproc::AudioProcessingConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:audioproc.ProcessAudioRequest.config)
}

// -------------------------------------------------------------------

// ProcessAudioResponse

// bytes wav_data = 1;
inline void ProcessAudioResponse::clear_wav_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wav_data_.ClearToEmpty();
}
inline const std::string& ProcessAudioResponse::wav_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:audioproc.ProcessAudioResponse.wav_data)
  return _internal_wav_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ProcessAudioResponse::set_wav_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wav_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:audioproc.ProcessAudioResponse.wav_data)
}
inline std::string* ProcessAudioResponse::mutable_wav_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_wav_data();
  // @@protoc_insertion_point(field_mutable:audioproc.ProcessAudioResponse.wav_data)
  return _s;
}
inline const std::string& ProcessAudioResponse::_internal_wav_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wav_data_.Get();
}
inline void ProcessAudioResponse::_internal_set_wav_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wav_data_.Set(value, GetArena());
}
inline std::string* ProcessAudioResponse::_internal_mutable_wav_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.wav_data_.Mutable( GetArena());
}
inline std::string* ProcessAudioResponse::release_wav_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:audioproc.ProcessAudioResponse.wav_data)
  return _impl_.wav_data_.Release();
}
inline void ProcessAudioResponse::set_allocated_wav_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wav_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.wav_data_.IsDefault()) {
          _impl_.wav_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:audioproc.ProcessAudioResponse.wav_data)
}

// -------------------------------------------------------------------

// SplitAudioRequest

// bytes wav_data = 1;
inline void SplitAudioRequest::clear_wav_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wav_data_.ClearToEmpty();
}
inline const std::string& SplitAudioRequest::wav_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:audioproc.SplitAudioRequest.wav_data)
  return _internal_wav_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SplitAudioRequest::set_wav_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wav_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:audioproc.SplitAudioRequest.wav_data)
}
inline std::string* SplitAudioRequest::mutable_wav_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_wav_data();
  // @@protoc_insertion_point(field_mutable:audioproc.SplitAudioRequest.wav_data)
  return _s;
}
inline const std::string& SplitAudioRequest::_internal_wav_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wav_data_.Get();
}
inline void SplitAudioRequest::_internal_set_wav_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wav_data_.Set(value, GetArena());
}
inline std::string* SplitAudioRequest::_internal_mutable_wav_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.wav_data_.Mutable( GetArena());
}
inline std::string* SplitAudioRequest::release_wav_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:audioproc.SplitAudioRequest.wav_data)
  return _impl_.wav_data_.Release();
}
inline void SplitAudioRequest::set_allocated_wav_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wav_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.wav_data_.IsDefault()) {
          _impl_.wav_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:audioproc.SplitAudioRequest.wav_data)
}

// string file_name = 2;
inline void SplitAudioRequest::clear_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& SplitAudioRequest::file_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:audioproc.SplitAudioRequest.file_name)
  return _internal_file_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SplitAudioRequest::set_file_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:audioproc.SplitAudioRequest.file_name)
}
inline std::string* SplitAudioRequest::mutable_file_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:audioproc.SplitAudioRequest.file_name)
  return _s;
}
inline const std::string& SplitAudioRequest::_internal_file_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.file_name_.Get();
}
inline void SplitAudioRequest::_internal_set_file_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.Set(value, GetArena());
}
inline std::string* SplitAudioRequest::_internal_mutable_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.file_name_.Mutable( GetArena());
}
inline std::string* SplitAudioRequest::release_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:audioproc.SplitAudioRequest.file_name)
  return _impl_.file_name_.Release();
}
inline void SplitAudioRequest::set_allocated_file_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.file_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.file_name_.IsDefault()) {
          _impl_.file_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:audioproc.SplitAudioRequest.file_name)
}

// .audioproc.ChunkingConfig config = 3;
inline bool SplitAudioRequest::has_config() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.config_ != nullptr);
  return value;
}
inline void SplitAudioRequest::clear_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.config_ != nullptr) _impl_.config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::audioproc::ChunkingConfig& SplitAudioRequest::_internal_config() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::audioproc::ChunkingConfig* p = _impl_.config_;
  return p != nullptr ? *p : reinterpret_cast<const ::audioproc::ChunkingConfig&>(::audioproc::_ChunkingConfig_default_instance_);
}
inline const ::audioproc::ChunkingConfig& SplitAudioRequest::config() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:audioproc.SplitAudioRequest.config)
  return _internal_config();
}
inline void SplitAudioRequest::unsafe_arena_set_allocated_config(::audioproc::ChunkingConfig* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.config_);
  }
  _impl_.config_ = reinterpret_cast<::audioproc::ChunkingConfig*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:audioproc.SplitAudioRequest.config)
}
inline ::audioproc::ChunkingConfig* SplitAudioRequest::release_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::audioproc::ChunkingConfig* released = _impl_.config_;
  _impl_.config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::audioproc::ChunkingConfig* SplitAudioRequest::unsafe_arena_release_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:audioproc.SplitAudioRequest.config)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::audioproc::ChunkingConfig* temp = _impl_.config_;
  _impl_.config_ = nullptr;
  return temp;
}
inline ::audioproc::ChunkingConfig* SplitAudioRequest::_internal_mutable_config() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.config_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::audioproc::ChunkingConfig>(GetArena());
    _impl_.config_ = reinterpret_cast<::audioproc::ChunkingConfig*>(p);
  }
  return _impl_.config_;
}
inline ::audioproc::ChunkingConfig* SplitAudioRequest::mutable_config() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::audioproc::ChunkingConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:audioproc.SplitAudioRequest.config)
  return _msg;
}
inline void SplitAudioRequest::set_allocated_config(::audioproc::ChunkingConfig* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.config_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.config_ = reinterpret_cast<::audioproc::ChunkingConfig*>(value);
  // @@protoc_insertion_point(field_set_allocated:audioproc.SplitAudioRequest.config)
}

// -------------------------------------------------------------------

// ChunkingConfig

// int32 sample_rate = 1;
inline void ChunkingConfig::clear_sample_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_rate_ = 0;
}
inline ::int32_t ChunkingConfig::sample_rate() const {
  // @@protoc_insertion_point(field_get:audioproc.ChunkingConfig.sample_rate)
  return _internal_sample_rate();
}
inline void ChunkingConfig::set_sample_rate(::int32_t value) {
  _internal_set_sample_rate(value);
  // @@protoc_insertion_point(field_set:audioproc.ChunkingConfig.sample_rate)
}
inline ::int32_t ChunkingConfig::_internal_sample_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sample_rate_;
}
inline void ChunkingConfig::_internal_set_sample_rate(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_rate_ = value;
}

// float threshold = 2;
inline void ChunkingConfig::clear_threshold() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threshold_ = 0;
}
inline float ChunkingConfig::threshold() const {
  // @@protoc_insertion_point(field_get:audioproc.ChunkingConfig.threshold)
  return _internal_threshold();
}
inline void ChunkingConfig::set_threshold(float value) {
  _internal_set_threshold(value);
  // @@protoc_insertion_point(field_set:audioproc.ChunkingConfig.threshold)
}
inline float ChunkingConfig::_internal_threshold() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.threshold_;
}
inline void ChunkingConfig::_internal_set_threshold(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.threshold_ = value;
}

// float chunk_min_duration_sec = 3;
inline void ChunkingConfig::clear_chunk_min_duration_sec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chunk_min_duration_sec_ = 0;
}
inline float ChunkingConfig::chunk_min_duration_sec() const {
  // @@protoc_insertion_point(field_get:audioproc.ChunkingConfig.chunk_min_duration_sec)
  return _internal_chunk_min_duration_sec();
}
inline void ChunkingConfig::set_chunk_min_duration_sec(float value) {
  _internal_set_chunk_min_duration_sec(value);
  // @@protoc_insertion_point(field_set:audioproc.ChunkingConfig.chunk_min_duration_sec)
}
inline float ChunkingConfig::_internal_chunk_min_duration_sec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.chunk_min_duration_sec_;
}
inline void ChunkingConfig::_internal_set_chunk_min_duration_sec(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chunk_min_duration_sec_ = value;
}

// float chunk_max_duration_sec = 4;
inline void ChunkingConfig::clear_chunk_max_duration_sec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chunk_max_duration_sec_ = 0;
}
inline float ChunkingConfig::chunk_max_duration_sec() const {
  // @@protoc_insertion_point(field_get:audioproc.ChunkingConfig.chunk_max_duration_sec)
  return _internal_chunk_max_duration_sec();
}
inline void ChunkingConfig::set_chunk_max_duration_sec(float value) {
  _internal_set_chunk_max_duration_sec(value);
  // @@protoc_insertion_point(field_set:audioproc.ChunkingConfig.chunk_max_duration_sec)
}
inline float ChunkingConfig::_internal_chunk_max_duration_sec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.chunk_max_duration_sec_;
}
inline void ChunkingConfig::_internal_set_chunk_max_duration_sec(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chunk_max_duration_sec_ = value;
}

// float overlap_duration_sec = 5;
inline void ChunkingConfig::clear_overlap_duration_sec() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.overlap_duration_sec_ = 0;
}
inline float ChunkingConfig::overlap_duration_sec() const {
  // @@protoc_insertion_point(field_get:audioproc.ChunkingConfig.overlap_duration_sec)
  return _internal_overlap_duration_sec();
}
inline void ChunkingConfig::set_overlap_duration_sec(float value) {
  _internal_set_overlap_duration_sec(value);
  // @@protoc_insertion_point(field_set:audioproc.ChunkingConfig.overlap_duration_sec)
}
inline float ChunkingConfig::_internal_overlap_duration_sec() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.overlap_duration_sec_;
}
inline void ChunkingConfig::_internal_set_overlap_duration_sec(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.overlap_duration_sec_ = value;
}

// -------------------------------------------------------------------

// SplitAudioResponse

// repeated .audioproc.AudioChunk chunks = 1;
inline int SplitAudioResponse::_internal_chunks_size() const {
  return _internal_chunks().size();
}
inline int SplitAudioResponse::chunks_size() const {
  return _internal_chunks_size();
}
inline void SplitAudioResponse::clear_chunks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chunks_.Clear();
}
inline ::audioproc::AudioChunk* SplitAudioResponse::mutable_chunks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:audioproc.SplitAudioResponse.chunks)
  return _internal_mutable_chunks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::audioproc::AudioChunk>* SplitAudioResponse::mutable_chunks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:audioproc.SplitAudioResponse.chunks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_chunks();
}
inline const ::audioproc::AudioChunk& SplitAudioResponse::chunks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:audioproc.SplitAudioResponse.chunks)
  return _internal_chunks().Get(index);
}
inline ::audioproc::AudioChunk* SplitAudioResponse::add_chunks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::audioproc::AudioChunk* _add = _internal_mutable_chunks()->Add();
  // @@protoc_insertion_point(field_add:audioproc.SplitAudioResponse.chunks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::audioproc::AudioChunk>& SplitAudioResponse::chunks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:audioproc.SplitAudioResponse.chunks)
  return _internal_chunks();
}
inline const ::google::protobuf::RepeatedPtrField<::audioproc::AudioChunk>&
SplitAudioResponse::_internal_chunks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.chunks_;
}
inline ::google::protobuf::RepeatedPtrField<::audioproc::AudioChunk>*
SplitAudioResponse::_internal_mutable_chunks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.chunks_;
}

// -------------------------------------------------------------------

// AudioChunk

// float start_time = 1;
inline void AudioChunk::clear_start_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_ = 0;
}
inline float AudioChunk::start_time() const {
  // @@protoc_insertion_point(field_get:audioproc.AudioChunk.start_time)
  return _internal_start_time();
}
inline void AudioChunk::set_start_time(float value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:audioproc.AudioChunk.start_time)
}
inline float AudioChunk::_internal_start_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.start_time_;
}
inline void AudioChunk::_internal_set_start_time(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.start_time_ = value;
}

// bytes audio_data = 2;
inline void AudioChunk::clear_audio_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_data_.ClearToEmpty();
}
inline const std::string& AudioChunk::audio_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:audioproc.AudioChunk.audio_data)
  return _internal_audio_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AudioChunk::set_audio_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:audioproc.AudioChunk.audio_data)
}
inline std::string* AudioChunk::mutable_audio_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_audio_data();
  // @@protoc_insertion_point(field_mutable:audioproc.AudioChunk.audio_data)
  return _s;
}
inline const std::string& AudioChunk::_internal_audio_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.audio_data_.Get();
}
inline void AudioChunk::_internal_set_audio_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_data_.Set(value, GetArena());
}
inline std::string* AudioChunk::_internal_mutable_audio_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.audio_data_.Mutable( GetArena());
}
inline std::string* AudioChunk::release_audio_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:audioproc.AudioChunk.audio_data)
  return _impl_.audio_data_.Release();
}
inline void AudioChunk::set_allocated_audio_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.audio_data_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.audio_data_.IsDefault()) {
          _impl_.audio_data_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:audioproc.AudioChunk.audio_data)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace audioproc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_proto_2fprocessor_2eproto_2epb_2eh
